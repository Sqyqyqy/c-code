#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>


//打开关闭
//int main()
//{
//	//打开文件
//	//相对路径
//	FILE* pf = fopen("test.txt", "w");
//
//	//绝对路径
//	//FILE* pf = fopen("c:\\code\\test.txt", "w");
//
//	if (NULL == pf)
//	{
//		perror("fopen");
//		return 1;
//	}
//
//	//写文件
//
//
//	//关闭文件
//	fclose(pf);
//	pf = NULL;
//	return 0;
//}


//写文件
//int main()
//{
//	FILE* pf = fopen("test.txt", "w");
//	if (pf == NULL)
//	{
//		perror("fopen");
//		return 1;
//	}
//	//写文件
//	//fputc('a', pf);
//	//fputc('b', pf);
//	//fputc('c', pf);
//
//	//int i = 0;
//	//for(i=0;i<26;i++)
//	//{
//	//	fputc('a' + i, pf);
//	//}
//
//	fclose(pf);
//	pf = NULL;
//	return 0;
//}


//fgetc函数
//int main()
//{
//	//FILE* pf = fopen("test.txt", "w");
//	FILE* pf = fopen("test.txt", "r");
//	if (pf == NULL)
//	{
//		perror("fopen");
//		return 1;
//	}
//	//int i = 0;
//	//for(i=0;i<26;i++)
//	//{
//	//	fputc('a' + i, pf);
//	//}
//
//	//读文件
//	//int ch = fgetc(pf);
//	//printf("%c ", ch);//读到a
//
//	//int i = 0;
//	//for (i = 0; i < 26; i++)
//	//{
//	//	int ch = fgetc(pf);
//	//	printf("%c ", ch);//全读到
//	//}
//
//	//如果流遇到了文件末尾，函数将返回EOF
//	int ch = 0;
//	while ((ch = fgetc(pf)) != EOF)
//	{
//		printf("%c ", ch);//全读到
//	}
//
//	fclose(pf);
//	pf = NULL;
//	return 0;
//}

//与scanf函数类似
//int main()
//{
//	int a = 0;
//	int check = 0;
//	while ((check = scanf("%d", &a)) != EOF)
//	{
//		printf("%d\n", a);
//	}
//	printf("%d\n", check);// -1
//	return 0;
//}


//格式化输入输出函数
//struct S
//{
//	char name[10];
//	int age;
//	float score;
//};

//int main()
//{
//	struct S s = { "zhangsan",20,95.5f };
//	//FILE* pf = fopen("test.txt", "w");//写
//	FILE* pf = fopen("test.txt", "r");//读
//	if (NULL == pf)
//	{
//		perror("fopen");
//		return 1;
//	}
//	//写一个结构体的数据到文件中
//	//fprintf(pf,"%s %d %.2f", s.name, s.age, s.score);//写
//	fscanf(pf, "%s %d %f", s.name, &(s.age), &(s.score));//读
//	printf("%s %d %f", s.name, s.age, s.score);
//
//	fclose(pf);
//	pf = NULL;
//
//	return 0;
//}

//函数可以作用于所有输出流
//int main()
//{
//	struct S s = { 0 };
//	fscanf(stdin, "%s %d %f", s.name, &(s.age), &(s.score));
//	printf("%s %d %f\n", s.name, s.age, s.score);
//
//	fprintf(stdout,"%s %d %f", s.name, s.age, s.score);
//
//	int ch = fgetc(stdin);
//	fputc(ch,stdout);//输入:zhangsan 19 98 输出:换行
//	                 //输入:zhangsan 19 98(空格)A 输出:空格
//	                 //输入:zhangsan 19 98A 输出:A
//	return 0;
//}


//fwrite函数
//int main()
//{
//	struct S s = { "zhangsan",20,95.5f };
//	//FILE* pf = fopen("test.txt", "wb");//写
//	FILE* pf = fopen("test.txt", "rb");//读
//	if (NULL == pf)
//	{
//		perror("fopen");
//		return 1;
//	}
//
//	//fwrite(&s, sizeof(s), 1, pf);//写
//	fread(&s, sizeof(s), 1, pf);//读
//	printf("%s %d %f\n", s.name, s.age, s.score);
//
//	return 0;
//}


//测试 顺序读取1.1 fscanf
//struct S
//{
//	char name[10];
//	int age;
//	float score;
//};
//
//int main()
//{
//	FILE* pf = fopen("test.txt", "r");
//	if (NULL == pf)
//	{
//		perror("fopen");
//		return 1;
//	}
//	struct S s1 = { 0 };
//	struct S s2 = { 0 };
//	struct S s3 = { 0 };
//
//	fscanf(pf,"%s %d %f", s1.name, &(s1.age), &(s1.score));
//	fscanf(pf, "%s %d %f", s2.name, &(s2.age), &(s2.score));
//	fscanf(pf, "%s %d %f", s3.name, &(s3.age), &(s3.score));
//
//	printf("%s %d %f\n", s1.name, s1.age, s1.score);
//	printf("%s %d %f\n", s2.name, s2.age, s2.score);
//	printf("%s %d %f\n", s3.name, s3.age, s3.score);
//
//	return 0;
//}
//测试 顺序读取1.2 fgetc
//int main()
//{
//	FILE* pf = fopen("test.txt", "r");
//	if (NULL == pf)
//	{
//		perror("fopen");
//		return 1;
//	}
//	int ch = 0;
//	while ((ch = fgetc(pf)) != EOF)
//	{
//		printf("%c ", ch);
//	}
//	printf("%d\n", ch);
//
//	return 0;
//}


//fgets返回值测试
//int main()
//{
//	FILE* pf = fopen("test.txt", "r");
//	if (NULL == pf)
//	{
//		perror("fopen");
//		return 1;
//	}
//	for (int i = 0; i < 3; i++)
//	{
//		char arr[5] = "####";
//		char* a = fgets(arr, 5, pf);
//		if (a == NULL)
//		{
//			printf("NULL\n");
//		}
//		printf("%s\n", arr);
//	}
//
//	return 0;
//}


//学校oj题
//一个4*5的整型二维数组，从键盘输入数据，并对该数组的每一列按从小到大的顺序排列后输出
//法1：可以用冒泡排序
//法2：转置后qsort再转置      二维数组转置的方法总结？？？（未解决）
//     打印和转置的思路相同
//#include<stdlib.h>
//void reverse(int(*arr1)[5],int(*arr2)[4],int choose)
//{
//	//
//	int i,j;
//	if (choose == 4)
//	{
//		for (j = 0; j < 5; j++)
//		{
//			for (i = 0; i < 4; i++)
//			{
//				arr2[j][i] = arr1[i][j];
//			}
//		}
//	}
//	else
//	{
//		for (j = 0; j < 5; j++)
//		{
//			for (i = 0; i < 4; i++)
//			{
//				arr1[i][j] = arr2[j][i];
//			}
//		}
//	}
//}
//int cmp_int(const void* x, const void* y)
//{
//	return *(int*)x - *(int*)y;
//}
//int main()
//{
//	int arr[4][5];
//	int arr_ret[5][4];//转置后的数组
//	int i = 0;
//	int j = 0;
//	for (i = 0; i < 4; i++)
//	{
//		for (j = 0; j < 5; j++)
//		{
//			scanf("%d", &arr[i][j]);
//		}
//	}
//	reverse(arr,arr_ret,4);
//	for (i = 0; i < 5; i++)
//	{
//		qsort(arr_ret[i], 4, sizeof(int), cmp_int);
//	}
//	//reverse(arr,arr_ret,5);
//	for (i = 0; i < 4; i++)
//	{
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d ", arr_ret[j][i]);
//		}
//		printf("\n");
//	}
//
//	return 0;
//}
//测试
//int main()
//{
//	int arr[3][2] = { {1,2},{2,3},{3,4} };
//	int(*p)[2] = arr;
//	printf("%d\n", p[1][1]);//3
//	return 0;
//}


//输出n阶杨辉三角(1<=n<=30)
//int main()
//{
//	int arr[30][30] = { 0 };
//	int n = 0;
//	scanf("%d", &n);
//	int i = 0;
//	int j = 0;
//	for (i = 0; i < n; i++)
//	{
//		for (j = 0; j <= i; j++)
//		{
//			if (j == 0 || i == j)
//			{
//				arr[i][j] = 1;
//				printf("%d ", arr[i][j]);
//			}
//			else if (j < i)
//			{
//				arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j];
//				printf("%d ", arr[i][j]);
//			}
//		}
//		printf("\n");
//	}
//	return 0;
//}
