//测试 指针类型的连续定义
//int main()
//{
//	int* a, b;//a类型是int*
//			  //b类型是int
//	return 0;
//}


//offsetof宏
//写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明
//#define my_offsetof(type,mem) (int)(&(((type*)0)->mem))
////#include<stddef.h>
//struct S
//{
//	char i;
//	int a;
//};
//
//int main()
//{
//	printf("%d\n", my_offsetof(struct S, i));
//	printf("%d\n", my_offsetof(struct S, a));
//
//	//printf("%d\n", offsetof(struct S, a));
//	return 0;
//}
//


//交换奇偶位
//写一个宏，可以将一个整数的二进制位的奇数位和偶数位交换
//int main()
//{
//	//00000000000000000000000000001011
//	//10101010101010101010101010101010 //拿出所有偶数位
//	//01010101010101010101010101010101 //拿出所有奇数位
//
//	//00000000000000000000000000001010 //所有偶数位
//	//00000000000000000000000000000101 //右移1位
//
//	//00000000000000000000000000000001 //所有奇数位
//	//00000000000000000000000000000010 //左移1位
//	int a = 10;
//	int ret = ((a & (0xaaaaaaaa))>>1) + ((a & (0x55555555))<<1);
//	printf("%d\n", ret);//5
//	//再次交换奇偶位
//	ret = ((ret & (0xaaaaaaaa)) >> 1) + ((ret & (0x55555555)) << 1);
//	printf("%d\n", ret);//10
//
//	return 0;
//}
//实现宏
//#define CHANGE(n) ((((n)&0xaaaaaaaa)>>1) + (((n)&0x55555555)<<1))
//#define CHANGE1(n) n = (((n&0xaaaaaaaa)>>1) + ((n&0x55555555)<<1))
//int main()
//{
//	int a = -10;
//	//没有改变a本身
//	//printf("%d\n", CHANGE(a));
//	//printf("%d\n", CHANGE(CHANGE(a)));
//
//	//或者改变a本身
//	/*CHANGE1(a);
//	printf("%d\n", a);
//	CHANGE1(a);
//	printf("%d\n", a);*/
//
//	//我问题：对于负数，偶数位右移时，如果左边补1，那这种方法是不是有问题
//	//下面是测试：（测试总结:若右移1位左边补0则结果正确，补1时结果错误；这里发现右移1位左边补1还是0是不确定的？？？）
//	//自己推导（1.1）
////11111111111111111111111111110110 -10补码
////11111111111111111111111111111001 奇偶位交换后
////10000000000000000000000000000110 奇偶位交换后应该得到-7
//
//	//用本方法推导（1.2）
//// 11010101010101010101010101010001 偶数位拿出来并右移1位 左边补1 补码 -715827887
//// 10101010101010101010101010101000 奇数位拿出来并左移1位 补码 - 1431655768
////101111111111111111111111111111001 相加得到该结果（1.1.1）
//// 01111111111111111111111111111001 对该结果丢掉进位得到的是2147483641 并不等于-7
//	//检验（1.1.1）是否正确
//// 10101010101010101010101010101111 原码 -715827887
//// 11010101010101010101010101011000 原码 -1431655768
//	//-715827887和-1431655768相加得-2147483655，整型最大值2147483647+1得-2147483648再+1得-2147483647，按此规律可以推出2147483641
//	printf("%d\n", -715827887 - 1431655768);// 2147483641
//
//	//(-1)+(-2)运算 （检验运算过程（1.1.1）是否正确）
//// 11111111111111111111111111111111 -1
//// 11111111111111111111111111111110 -2
////111111111111111111111111111111101 （-1）+（-2）
//// 10000000000000000000000000000011 -3
//
//	//观察实际运算过程（2）
//	//取出所有偶数位（2.1）
//	printf("%d\n", (a & 0xaaaaaaaa));// -1431655774
//	printf("%d\n", (a & 0xaaaaaaaa)>>1);// 1431655761
////10000000000000000000000000001010 -10原码
////11111111111111111111111111110110 -10补码
////10101010101010101010101010100010 偶数位 补码
////11010101010101010101010101011110 原 -1431655774
////01010101010101010101010101010001 右移1位 左边补0？？？？？？？？原码 1431655761
//	//用整数1测试，右移1位左边补0还是1，测得左边补1
//	printf("%d\n", (-1) >> 1);
////10000000000000000000000000000001 -1原码
////11111111111111111111111111111111 -1补码
////11111111111111111111111111111111 右移1位 补码 左边补1？？？？？？？？
////10000000000000000000000000000001 -1 原码
//
//	//取出所有奇数位（2.2）
//	printf("%d\n", a & 0x55555555);// 1431655764
//	printf("%d\n", (a & 0x55555555)<<1);// -1431655768
////10000000000000000000000000001010 -10原码
////11111111111111111111111111110110 -10补码
////01010101010101010101010101010100 奇数位 原码 1431655764
////10101010101010101010101010101000 左移1位 补码
////11010101010101010101010101011000 原码 -1431655768
//	
//	//相加（2.3）
////11111111111111111111111111111001 奇数位左移1位和偶数位右移1位后相加 补码
////10000000000000000000000000000111 原码 -7
//	return 0;
//}


//读整行的需求
//int main()
//{
//	char str[30];
//	scanf("%[^\n]%*c", str);
//	printf("%s\n", str);
//
//	char str1[30];
//	scanf("%s", str1);
//	printf("%s\n", str1); 
//
//	return 0;
//}

